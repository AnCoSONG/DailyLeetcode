# 思路

从题解来看，这个思路其实很清晰。主要是围绕两个问题。

1. 如何求最短路径？
这里使用的是BFS，BFS之所以可以求最短路径，是因为它按层搜索，这样最短的路径会被最早的搜索到。

2. 如何解决成环问题？
由于这里的节点可以重复利用，所以传统的`vis[]`的方式不可行，这里使用了二进制状态的方式记录节点的状态，非常巧妙。

关于二进制状态，举例说明比较好理解。如当前`graph=[[1,2,3],[0],[0],[0]]`，表示有4个节点，0，1，2，3，对应的状态是`0001, 0010, 0100, 1000`。如果从0->1，则两个状态**取或**，得到状态`0011`。显然，走过所有节点的最短路径，就是BFS搜索过程中第一次遇到`1111`状态的节点。

实现上，使用数组`vis[n][2^n]`记录以每个节点为初始节点的所有状态，默认全为`false`，当进入该节点时，会把当前的状态标记为true，标记为true后如果以该状态进入该节点，说明循环搜索，不允许进入。

总的来说，本题就是使用BFS搜索全为1的目标状态，如`11111`。

我本人遇到最短路径问题总是会先考虑使用DFS，但是DFS相比BFS其实还是优缺点，主要在于DFS需要搜索全部的结果取最小值，而BFS由于是层次遍历，会更快找到最短路径，从而更快返回。
